<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>FPS Shooter</title>
    <style>
        body { margin: 0; overflow: hidden; background: black; }
        #startScreen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: #000d;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 32px;
            cursor: pointer;
            z-index: 10;
        }
        #crosshair {
            position: absolute;
            top: 50%; left: 50%;
            width: 12px; height: 12px;
            margin-left: -6px; margin-top: -6px;
            border: 2px solid white;
            border-radius: 50%;
            pointer-events: none;
            z-index: 5;
        }
    </style>
</head>
<body>
    <div id="startScreen">CLICK TO START</div>
    <div id="crosshair"></div>

    <!-- Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r155/three.min.js"></script>

    <script>
    let scene, camera, renderer;
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    let controlsEnabled = false;
    let objects = [];

    const startScreen = document.getElementById("startScreen");

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x202020);

        camera = new THREE.PerspectiveCamera(
            75, window.innerWidth / window.innerHeight, 1, 2000
        );

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Floor
        let floor = new THREE.Mesh(
            new THREE.PlaneGeometry(400, 400),
            new THREE.MeshPhongMaterial({ color: 0x444444 })
        );
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        // Lighting
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(50, 100, 50);
        scene.add(light);

        // Controls start on click
        startScreen.onclick = () => {
            startScreen.style.display = "none";
            document.body.requestPointerLock();
        };

        document.addEventListener("pointerlockchange", () => {
            controlsEnabled = document.pointerLockElement === document.body;
        });

        // Mouse look
        document.addEventListener("mousemove", (e) => {
            if (!controlsEnabled) return;
            camera.rotation.y -= e.movementX * 0.002;
            camera.rotation.x -= e.movementY * 0.002;
            camera.rotation.x = Math.max(-1.4, Math.min(1.4, camera.rotation.x));
        });

        // WASD
        document.addEventListener("keydown", (e) => {
            if (e.code === "KeyW") moveForward = true;
            if (e.code === "KeyS") moveBackward = true;
            if (e.code === "KeyA") moveLeft = true;
            if (e.code === "KeyD") moveRight = true;
        });

        document.addEventListener("keyup", (e) => {
            if (e.code === "KeyW") moveForward = false;
            if (e.code === "KeyS") moveBackward = false;
            if (e.code === "KeyA") moveLeft = false;
            if (e.code === "KeyD") moveRight = false;
        });

        // Shooting
        document.addEventListener("mousedown", shoot);

        spawnTargets();
        animate();
    }

    function spawnTargets() {
        const geo = new THREE.BoxGeometry(3, 3, 3);
        const mat = new THREE.MeshPhongMaterial({ color: 0xff3333 });

        for (let i = 0; i < 15; i++) {
            let box = new THREE.Mesh(geo, mat.clone());
            box.position.set(
                Math.random() * 200 - 100,
                1.5,
                Math.random() * 200 - 100
            );
            scene.add(box);
            objects.push(box);
        }
    }

    function shoot() {
        if (!controlsEnabled) return;

        const ray = new THREE.Raycaster();
        ray.setFromCamera(new THREE.Vector2(0, 0), camera);
        const hit = ray.intersectObjects(objects);

        if (hit.length > 0) {
            let obj = hit[0].object;
            scene.remove(obj);
            objects = objects.filter(o => o !== obj);
        }
    }

    function animate() {
        requestAnimationFrame(animate);

        if (controlsEnabled) {
            const speed = 0.3;

            if (moveForward) {
                camera.position.x -= Math.sin(camera.rotation.y) * speed;
                camera.position.z -= Math.cos(camera.rotation.y) * speed;
            }
            if (moveBackward) {
                camera.position.x += Math.sin(camera.rotation.y) * speed;
                camera.position.z += Math.cos(camera.rotation.y) * speed;
            }
            if (moveLeft) {
                camera.position.x -= Math.cos(camera.rotation.y) * speed;
                camera.position.z += Math.sin(camera.rotation.y) * speed;
            }
            if (moveRight) {
                camera.position.x += Math.cos(camera.rotation.y) * speed;
                camera.position.z -= Math.sin(camera.rotation.y) * speed;
            }
        }

        renderer.render(scene, camera);
    }

    init();
    </script>
</body>
</html>
